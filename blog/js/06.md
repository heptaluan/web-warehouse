`ECMAScirpt` 变量有两种不同的数据类型：基本类型，引用类型

引用就像一种特殊的指针，是来指向变量的指针（别名），如果参数不声明为引用的话，参数值总是通过值复制的方式传递，即便对复杂的对象值也是如此

* `JavaScript` 中没有指针，引用的工作机制也不尽相同，在 `JavaScript` 中变量不可能成为指向另一个变量的引用

* `JavaScript` 引用指向的是值，如果一个值有 `10` 个引用，这些引用指向的都是同一个值，它们相互之间没有 引用/指向 关系

* `JavaScript` 对值和引用的 赋值/传递 在语法上没有区别，完全根据值的类型来决定

先来看一个例子

```js
var a = 2;
var b = a;  // b 是 a 的值的一个副本

b++;

a;  // 2
b;  // 3

// ===>

var c = [1, 2, 3];
var d = c;

d.push(4);

c;  // [1, 2, 3, 4]
d;  // [1, 2, 3, 4]
```

上例中的 `2` 是一个标量基本类型值，所以变量 `a` 持有该值的一个副本，`b` 持有它的另一个复本，所以，`b` 更改时，`a` 的值保持不变

`c` 和 `d` 则分别指向同一个复合值 `[1, 2, 3]` 的两个不同引用，请注意，`c` 和 `d` 仅仅是指向值 `[1, 2, 3]`，并非持有，所以它们更改的是同一个值（比如调用 `push()` 方法），随后它们都指向了更改后的新值 `[1, 2, 3, 4]`

* 简单值（即标量基本类型值，`scalar primitive`）总是通过值复制的方式来 赋值/传递，包括 `undefined`，`boolean`，`number`，`string`，`null` 和 ES6 中的 `Symbol`

* 复合值（`compound value`）-- 对象（包括数组和封装对象）和函数，则总是通过引用复制的方式来 赋值/传递

由上可知，由于引用指向的是值本身而非变量，所以一个引用无法更改另外一个引用的指向

```js
var a = [1, 2, 3];
var b = a;

a;  // [1, 2, 3]
b;  // [1, 2, 3]

// ===>

b = [4, 5, 6];
a;  // [1, 2, 3]
b;  // [4, 5, 6]
```

从上面例子可以看出 `b = [4, 5, 6]` 并不影响 `a` 指向 `[1, 2, 3]`



## 引用类型值的传递

但是函数的参数就经常让人产生这样的疑惑

```js
function foo (x) {
  x.push(4);
  x;  // [1, 2, 3, 4]

  // ===>

  x = [4, 5, 6];
  x.push(7);
  x;  // [4, 5, 6, 7]
}

var a = [1, 2, 3];
foo(a);

a;  // [1, 2, 3, 4]
```

我们向函数传递 `a` 的时候，实际是将引用 `a` 的一个复本赋值给 `x`，而 `a` 仍然指向 `[1, 2, 3]`

在函数中我们可以通过引用 `x` 来更改数组的值（如上，数组在 `push(4)` 后变为了 `[1, 2, 3, 4]`），但 `x = [4, 5, 6]` 并不影响 `a` 的指向，所以 `a` 仍然指向 `[1, 2, 3, 4]`

我们不能通过引用 `x` 来更改引用 `a` 的指向，只能更改 `a` 和 `x` 共同指向的值，如果要将 `a` 的值变为 `[4, 5, 6, 7]`，那么就必须更改 `x` 指向的数组，而不是为 `x` 赋值一个新的数组

```js
function foo (x) {
  x.push(4);
  x;  // [1, 2, 3, 4]

  // ===>

  x.length = 0;
  x.push(4, 5, 6, 7);
  x;  // [4, 5, 6, 7]
}

var a = [1, 2, 3];
foo(a);

a;  // [4, 5, 6, 7]
```

这样一来，在不创建新数组，而只是更改了当前的数组的情况下，`a` 的指向就变成了 `[4, 5, 6, 7]`

> 我们无法自行决定使用值复制还是引用复制，一切由值的类型来决定

如果通过值复制的方式来传递复合值（数组），那么就需要为其创建一个复本，这样传递的就不再是原始值，比如

```js
// slice() 方法不传参数的情况会返回当前数组的一个浅副本（shallow copy）
foo(a.slice())
```

这样一来，由于传递给函数的是指向该副本的引用，所以 `foo()` 中的操作不会再影响 `a` 指向的数组


## 基本类型值的传递

相反，如果要将标量基本类型值传递到函数内并进行更改，这时候就需要将该值封装到一个复合值（对象，数组等）中，然后通过引用复制的方式传递

```js
function foo (wrap) {
  wrap.a = 22;
}

var obj = {
  a: 2
}

foo(obj); 

obj.a;  // 22
```

这里的 `obj` 是一个封装了标量基本类型值 `a` 的封装对象，`obj` 引用的一个复本作为参数 `wrap` 被传递到 `foo()` 中

这样我们就可以通过 `wrap` 来访问该对象并更改它的属性，函数执行结束后 `obj.a` 的值就变为了 `22`

与预期不同的是，虽然传递的是指向数字对象的引用复本，但我们并不能通过它来更改其中的基本类型值：

```js
function foo (x) {
  x = x + 1;
  x;  // 3
}

var a = 2;
var b = new Number(a);  // Objeact(a) 也是一样

foo(b);
b;  // 2，而不是 3
```

这是因为标量基本类型的值是不可更改的（字符串和布尔也是如此），如果一个数字对象的标量基本类型值是 `2`，那么该值就不能更改，除非创建一个包含新值的数字对象

`x = x + 1` 中，`x` 中的标量基本类型值 `2` 从数字对象中拆封（提取）出来以后，x 就从引用变成了数字对象，它的值为 `2 + 1` 等于 `3`，然而函数外的 `b` 仍然指向原来那个值为 `2` 的数字对象

最后再来看两个小小的案例

```js
// 第一个
var o1 = new Object();
var o2 = o1;

o2.name = 'a';
console.log(o1.name);  // a

// 第二个
function changeObjectProperty (o) {
  o.name = 'a';
  o = new Object();
  o.name = 'b';
  console.log(o.name);
}

var o = new Object();

changeObjectProperty(o);
console.log(o.name); 
```

第一个就不用多说了，看了上面的内容以后应该会很清晰的得出 `o1.name` 也是为 `a` 的（引用的同一个地址）

至于第二个，如果 `o` 是按引用传递的，那么结果应该是 `'b'`，但实际结果却仍是 `'a'`

在函数内部修改了引用类型值的参数，该参数值的原始引用保持不变，我们可以把参数想象成局部变量，当参数被重写时，这个变量引用的就是一个局部变量，局部变量的生存期仅限于函数执行的过程中，函数执行完毕，局部变量即被销毁以释放内存  

> 内部环境可以通过作用域链访问所有的外部环境中的变量对象，但外部环境无法访问内部环境。每个环境都可以向上搜索作用域链，以查询变量和函数名，反之向下则不能

如何引用一个对象，但是不改变原有对象的值（解决方法就是在一个函数中去引用），所以


* 对于保存基本类型值的变量，变量是按值访问的，因为我们操作的是变量实际保存的值

* 对于保存引用类型值的变量，变量是按引用访问的，我们操作的是变量值所引用（指向）的对象

