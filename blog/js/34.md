# JavaScript 中的数据绑定

关于数据双向绑定，绑定的基础就是监听属性的变化事件（`propertyChange`），现在主流的框架当中的解决方法一般有以下几种

* `Knockout` / `Backbone`（发布/订阅模式），简单来说就是另外开发一套 `API`，但使用起来却不得不使用这套 `API` 来操作 `viewModel`，导致上手复杂、代码繁琐

* `Angular`（脏检查机制），特点是直接使用原生 `JavaScript` 来操作 `viewModel`，但脏检查机制随之带来的就是性能问题

* `Vue`（数据劫持，也就是 `Object.defineProperty`），会把定义的 viewModel 对象（即 `data` 函数返回的对象）中所有的（除某些前缀开头的）成员替换为属性，这样既可以使用原生 `JavaScript` 操作对象，又可以主动触发 `propertyChange` 事件，效率虽高，但也有一些限制，见后文

另外的几种方式

* `Object.observe`，谷歌对于简化双向绑定机制的尝试，在 `Chrome 49` 中引入，然而由于性能等问题，并没有被其他各大浏览器及 `ES` 标准所接受，所以在后续版本当中移除了该方法的实现

* `Proxy`，是 `ES6` 加入的新特性，用于对某些基本操作定义其自定义行为，类似于其他语言中的面向切面编程（它的其中一个作用就是用于（部分）替代 `Object.observe` 以实现双向绑定）



## 基于数据劫持实现的双向绑定

#### 什么是数据劫持

数据劫持比较好理解，通常我们利用 `Object.defineProperty` 劫持对象的访问器，在属性值发生变化时我们可以获取变化，从而进行进一步操作

```js
// 这是将要被劫持的对象
const data = {
  name: '',
};

// 测试函数
function test(name) {
  console.log(name);
}

// 遍历对象,对其属性值进行劫持
Object.keys(data).forEach(function (key) {
  Object.defineProperty(data, key, {
    enumerable: true,
    configurable: true,
    get: function () {
      console.log(`get`);
    },
    set: function (newValue) {
      // 当属性值发生变化时我们可以进行额外操作
      console.log(`set`);
      test(newValue);
    },
  });
});

data.name = `new name`;
```

#### 数据劫持的优势以及实现思路

目前业界分为两个大的流派，一个是以 `React` 为首的单向数据绑定，另一个是以 `Angular`、`Vue` 为主的双向数据绑定

两者主要有两点区别

* 无需显示调用，例如 `Vue` 运用数据劫持加上发布订阅，直接可以通知变化并驱动视图，而比如 `Angular` 的脏检测或是 `react` 需要显示调用 `setState`

* 可精确得知变化数据：例如上面的例子，我们劫持了属性的 `setter`，当属性值改变，我们可以精确获知变化的内容，因此在这部分不需要额外的 `diff` 操作，否则我们只知道数据发生了变化而不知道具体哪些数据变化了，这个时候需要大量 `diff` 来找出变化值，这是额外性能损耗

本质上，基于数据劫持的双向绑定离不开 `Proxy` 与 `Object.defineProperty` 等方法对对象/对象属性的"劫持"，我们要实现一个完整的双向绑定需要以下几个要点

* 利用 `Proxy` 或 `Object.defineProperty` 生成的 `Observer` 针对对象/对象的属性进行"劫持"，在属性发生变化后通知订阅者

* 解析器 `Compile` 解析模板中的 `Directive`（指令），收集指令所依赖的方法和数据，等待数据变化然后进行渲染

* `Watcher` 属于 `Observer` 和 `Compile` 桥梁，它将接收到的 `Observer` 产生的数据变化，并根据 `Compile` 提供的指令进行视图渲染，使得数据变化促使视图变化

![IMG](https://raw.githubusercontent.com/heptaluan/blog/master/essay/js/%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A.png)



#### 基于 Object.defineProperty 双向绑定

完整的实现可以见 [剖析 Vue 原理 && 实现双向绑定 MVVM](https://segmentfault.com/a/1190000006599500)，比如上面的示例，就是一个简单的实现

但是很快就会发现，里面存在着一堆问题，比如我们只监听了一个属性，一个对象不可能只有一个属性，我们需要对对象的每个属性进行监听等等

我们可以参考 `Vue` 的实现方式，`Vue` 的操作就是加入了发布订阅模式，结合 `Object.defineProperty` 的劫持能力，实现了可用性很高的双向绑定

下面是一个完成的例子

```html
<main>
  <p>请输入:</p>
  <input type="text" id="input">
  <p id="p"></p>
</main>
```

```js
// 首先实现一个订阅发布中心，即消息管理员（Dep），它负责储存订阅者和消息的分发，不管是订阅者还是发布者都需要依赖于它
const Vue = (function() {

  let uid = 0;

  // 用于储存订阅者并发布消息
  class Dep {

    constructor() {
      // 设置 id 用于区分新 Watcher 和只改变属性值后新产生的 Watcher
      this.id = uid++;
      // 储存订阅者的数组
      this.subs = [];
    }

    // 触发 target 上的 Watcher 中的 addDep 方法，参数为 dep 的实例本身
    depend() {
      Dep.target.addDep(this);
    }

    // 添加订阅者
    addSub(sub) {
      this.subs.push(sub);
    }

    notify() {
      // 通知所有的订阅者（Watcher）触发订阅者的相应逻辑处理
      this.subs.forEach(sub => sub.update());
    }
  }

  // 为 Dep 类设置一个静态属性，默认为 null，工作时指向当前的 Watcher
  Dep.target = null;
  
  // 现在我们需要实现监听者（Observer），用于监听属性值的变化
  // 监听者，监听对象属性值的变化
  class Observer {

    constructor(value) {
      this.value = value;
      this.walk(value);
    }

    // 遍历属性值并监听
    walk(value) {
      Object.keys(value).forEach(key => this.convert(key, value[key]));
    }

    // 执行监听的具体方法
    convert(key, val) {
      defineReactive(this.value, key, val);
    }

  }

  function defineReactive(obj, key, val) {

    const dep = new Dep();

    // 给当前属性的值添加监听

    let chlidOb = observe(val);
    
    Object.defineProperty(obj, key, {
      enumerable: true,
      configurable: true,
      get: () => {
        // 如果 Dep 类存在 target 属性，将其添加到 dep 实例的 subs 数组中
        // target 指向一个 Watcher 实例，每个 Watcher 都是一个订阅者
        // Watcher 实例在实例化过程中，会读取 data 中的某个属性，从而触发当前 get 方法
        if (Dep.target) {
          dep.depend();
        }
        return val;
      },
      set: newVal => {
        if (val === newVal) return;
        val = newVal;
        // 对新值进行监听
        chlidOb = observe(newVal);
        // 通知所有订阅者，数值被改变了
        dep.notify();
      },
    });
  }

  function observe(value) {
    // 当值不存在，或者不是复杂数据类型时，不再需要继续深入监听
    if (!value || typeof value !== 'object') {
      return;
    }
    return new Observer(value);
  }


  // 我们还需要实现一个订阅者（Watcher）
  class Watcher {

    constructor(vm, expOrFn, cb) {
      this.depIds = {};       // hash 储存订阅者的 id，避免重复的订阅者
      this.vm = vm;           // 被订阅的数据一定来自于当前 Vue 实例
      this.cb = cb;           // 当数据更新时想要做的事情
      this.expOrFn = expOrFn; // 被订阅的数据
      this.val = this.get();  // 维护更新之前的数据
    }

    // 对外暴露的接口，用于在订阅的数据被更新时，由订阅者管理员（Dep）调用
    update() {
      this.run();
    }

    addDep(dep) {
      // 如果在 depIds 的 hash 中没有当前的 id，可以判断是新 Watcher，因此可以添加到 dep 的数组中储存
      // 此判断是避免同 id 的 Watcher 被多次储存
      if (!this.depIds.hasOwnProperty(dep.id)) {
        dep.addSub(this);
        this.depIds[dep.id] = dep;
      }
    }

    run() {
      const val = this.get();
      console.log(val);
      if (val !== this.val) {
        this.val = val;
        this.cb.call(this.vm, val);
      }
    }

    get() {
      // 当前订阅者（Watcher）读取被订阅数据的最新更新后的值时，通知订阅者管理员收集当前订阅者
      Dep.target = this;
      const val = this.vm._data[this.expOrFn];
      // 置空，用于下一个 Watcher 使用
      Dep.target = null;
      console.log(Dep.target, 2);
      return val;
    }
  }

  
  // 将上述方法挂载在 Vue 上
  class Vue {

    constructor(options = {}) {
      // 简化了 $options 的处理
      this.$options = options;
      // 简化了对 data 的处理
      let data = (this._data = this.$options.data);
      // 将所有 data 最外层属性代理到 Vue 实例上
      Object.keys(data).forEach(key => this._proxy(key));
      // 监听数据
      observe(data);
    }

    // 对外暴露调用订阅者的接口，内部主要在指令中使用订阅者
    $watch(expOrFn, cb) {
      new Watcher(this, expOrFn, cb);
    }

    _proxy(key) {
      Object.defineProperty(this, key, {
        configurable: true,
        enumerable: true,
        get: () => this._data[key],
        set: val => {
          this._data[key] = val;
        },
      });
    }

  }

  return Vue;
})();


// 使用
let demo = new Vue({
  data: {
    text: '',
  },
});

const p = document.getElementById('p');
const input = document.getElementById('input');

input.addEventListener('keyup', function(e) {
  demo.text = e.target.value;
});

demo.$watch('text', str => p.innerHTML = str);
```


#### Object.defineProperty 的缺陷

其实我们升级版的双向绑定依然存在漏洞，比如我们将属性值改为数组

```js
let demo = new Vue({
  data: {
    list: [1],
  },
});

const list = document.getElementById('list');
const btn = document.getElementById('btn');

btn.addEventListener('click', function () {
  demo.list.push(1);
});

const render = arr => {
  const fragment = document.createDocumentFragment();
  for (let i = 0; i < arr.length; i++) {
    const li = document.createElement('li');
    li.textContent = arr[i];
    fragment.appendChild(li);
  }
  list.appendChild(fragment);
};

// 监听数组，每次数组变化则触发渲染函数，然而却无法监听
demo.$watch('list', list => render(list));

setTimeout(
  function () {
    alert(demo.list);
  },
  5000,
);
```

是的，`Object.defineProperty` 的第一个缺陷，无法监听数组变化，然而 `Vue` 的文档提到了 `Vue` 是可以检测到数组变化的

其实简单来说，这里就是重写了原来的方法

```js
const aryMethods = ['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'];
const arrayAugmentations = [];

aryMethods.forEach((method) => {

  // 这里是原生 Array 的原型方法
  let original = Array.prototype[method];

  // 将 push, pop 等封装好的方法定义在对象 arrayAugmentations 的属性上
  // 注意：是属性而非原型属性
  arrayAugmentations[method] = function () {
    console.log('我被改变啦!');
    // 调用对应的原生方法并返回结果
    return original.apply(this, arguments);
  };

});

let list = ['a', 'b', 'c'];

// 将我们要监听的数组的原型指针指向上面定义的空数组对象
// 别忘了这个空数组的属性上定义了我们封装好的 push 等方法
list.__proto__ = arrayAugmentations;
list.push('d');  // 我被改变啦！ 4

// 这里的 list2 没有被重新定义原型指针，所以就正常输出
let list2 = ['a', 'b', 'c'];
list2.push('d');  // 4
```

由于只针对了八种方法进行了 `hack`，所以其他数组的属性也是检测不到的

我们应该注意到在上文中的实现里，我们多次用遍历方法遍历对象的属性，这就引出了 `Object.defineProperty` 的第二个缺陷，只能劫持对象的属性

因此我们需要对每个对象的每个属性进行遍历，如果属性值也是对象那么需要深度遍历，显然能劫持一个完整的对象是更好的选择

```js
Object.keys(value).forEach(key => this.convert(key, value[key]));
```



## Proxy 实现的双向绑定

`Proxy` 在 `ES2015` 规范中被正式发布，它在目标对象之前架设一层"拦截"，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写

我们可以这样认为 `Proxy` 是 `Object.defineProperty` 的全方位加强版

`Proxy` 直接可以劫持整个对象，并返回一个新对象，不管是操作便利程度还是底层功能上都远强于 `Object.defineProperty`


#### Proxy 可以直接监听数组的变化

当我们对数组进行操作（`push`、`shift`、`splice` 等）时，会触发对应的方法名称和 `length` 的变化

下面是一个实例

```html
<main>
  <ul id="list">
  </ul>
  <button type="button" name="button" id="btn">添加列表项</button>
</main>
```

```js
const list = document.getElementById('list');
const btn = document.getElementById('btn');

// 渲染列表
const Render = {

  // 初始化
  init: function(arr) {
    const fragment = document.createDocumentFragment();
    for (let i = 0; i < arr.length; i++) {
      const li = document.createElement('li');
      li.textContent = arr[i];
      fragment.appendChild(li);
    }
    list.appendChild(fragment);
  },

  // 我们只考虑了增加的情况，仅作为示例
  change: function(val) {
    const li = document.createElement('li');
    li.textContent = val;
    list.appendChild(li);
  },
};

// 初始数组
const arr = [1, 2, 3, 4];

// 监听数组
const newArr = new Proxy(arr, {
  get: function(target, key, receiver) {
    console.log(key);
    return Reflect.get(target, key, receiver);
  },
  set: function(target, key, value, receiver) {
    console.log(target, key, value, receiver);
    if (key !== 'length') {
      Render.change(value);
    }
    return Reflect.set(target, key, value, receiver);
  },
});

// 初始化
window.onload = function() {
  Render.init(arr);
}

// push 数字
btn.addEventListener('click', function() {
  newArr.push(6);
});
```

#### Proxy的优势

`Proxy` 有多种拦截方法，不限于 `apply`、`ownKeys`、`deleteProperty`、`has` 等等，是 `Object.defineProperty` 不具备的

`Proxy` 返回的是一个新对象，我们可以只操作新的对象达到目的，而 `Object.defineProperty` 只能遍历对象属性直接修改
