参考 [CSS 伸缩盒布局模组](https://www.w3.org/html/ig/zh/css-flex-1/)

主要分为两部分，容器和元素，这里主要说的是应用在元素身上的 `flex` 属性取值的问题，下面是一些 `flex` 布局常用的属性和一些取值介绍

需要注意的是，如果将元素的 `display` 属性设置为 `flex`，那么其就转换为了 `Flex` 容器，在设为 `Flex` 容器后，其子元素的 `float`、`clear` 和 `vertical-align` 属性都将失效

## 容器的属性

有下面六个属性是应用在容器上面的

* `flex-direction`  属性决定主轴的方向（即项目的排列方向）

  * `row`（默认值）  主轴为水平方向，起点在左端

  * `row-reverse`  主轴为水平方向，起点在右端

  * `column`  主轴为垂直方向，起点在上沿

  * `column-reverse`  主轴为垂直方向，起点在下沿


* `flex-wrap`  默认情况下，项目都排在一条线（轴线）上，如果一条轴线排不下，如何换行

  * `nowrap`（默认）  不换行

  * `wrap`  换行，第一行在上方

  * `wrap-reverse`  换行，第一行在下方


* `flex-flow`  为 `flex-direction` 属性和 `flex-wrap` 属性的简写形式，默认值为 `row nowrap`

* `justify-content`  定义了项目在主轴上的对齐方式（左右）

  * `flex-start`（默认值）  左对齐

  * `flex-end`  右对齐

  * `center`   居中

  * `space-between`  两端对齐，项目之间的间隔都相等

  * `space-around`  每个项目两侧的间隔相等，所以，项目之间的间隔比项目与边框的间隔大一倍

* `align-items`  定义项目在交叉轴上如何对齐（上下）

  * `flex-start`  交叉轴的起点对齐

  * `flex-end`  交叉轴的终点对齐

  * `center`  交叉轴的中点对齐

  * `baseline`  项目的第一行文字的基线对齐

  * `stretch`（默认值）  如果项目未设置高度或设为 `auto`，将占满整个容器的高度

* `align-content`  定义了多根轴线的对齐方式如果项目只有一根轴线，无效（意思就是内容分为多行，类似 `line-height`）

  * `flex-start`  与交叉轴的起点对齐

  * `flex-end`  与交叉轴的终点对齐

  * `center`  与交叉轴的中点对齐

  * `space-between`  与交叉轴两端对齐，轴线之间的间隔平均分布

  * `space-around`  每根轴线两侧的间隔都相等，所以，轴线之间的间隔比轴线与边框的间隔大一倍

  * `stretch`（默认值）  轴线占满整个交叉轴




## 元素的属性

有下面六个属性是应用在元素身上的

* `order`  定义项目的排列顺序，数值越小，排列越靠前，默认为 `0`

* `flex-grow`  定义项目的放大比例，默认为 `0`，即如果存在剩余空间，也不放大

  * 如果所有项目的 `flex-grow` 属性都为 `1`，则它们将等分剩余空间（如果有的话）
  
  * 如果一个项目的 `flex-grow` 属性为 `2`，其他项目都为 `1`，则前者占据的剩余空间将比其他项多一倍（类似合并单元格）

* `flex-shrink`  定义了项目的缩小比例，默认为 `1`，即如果空间不足，该项目将缩小

  * 如果所有项目的 `flex-shrink` 属性都为 `1`，当空间不足时，都将等比例缩小
  
  * 如果一个项目的 `flex-shrink` 属性为 `0`，其他项目都为 `1`，则空间不足时，前者不缩小

* `flex-basis`  定义了在分配多余空间之前，项目占据的主轴空间

  * 浏览器根据这个属性，计算主轴是否有多余空间，它的默认值为 `auto`，即项目的本来大小

  * 它可以设为跟 `width` 或 `height` 属性一样的值，则项目将占据固定空间

* `flex`  是 `flex-grow`, `flex-shrink` 和 `flex-basis` 的简写，默认值为 `0 1 auto`，后两个属性可选

* `align-self`  允许单个项目有与其他项目不一样的对齐方式，可覆盖 `align-items` 属性（父级容器指定的排列方式）

  * 默认值为 `auto`，表示继承父元素的 `align-items` 属性，如果没有父元素，则等同于 `stretch`

  * 除了 `auto`，其他都与 `align-items` 属性完全一致




## flex

下面就来看看 `flex` 这个应用在元素身上的属性

首先明确一点是， `flex` 是 `flex-grow`、`flex-shrink`、`flex-basis` 的缩写

`flex` 的默认值是以上三个属性值的组合，假设以上三个属性同样取默认值，则 `flex` 的默认值是 `0 1 auto`，如下，是等同的

```css
.item {flex: 222 233 244px;}

.item {
  flex-grow: 222;
  flex-shrink: 233;
  flex-basis: 244px;
}
```

当 `flex` 取值为 `none`，则计算值为 `0 0 auto`，如下是等同的

```css
.item {flex: none;}

.item {
  flex-grow: 0;
  flex-shrink: 0;
  flex-basis: auto;
}
```

当 `flex` 取值为 `auto`，则计算值为 `1 1 auto`，如下是等同的

```css
.item {flex: auto;}

.item {
  flex-grow: 1;
  flex-shrink: 1;
  flex-basis: auto;
}
```

当 `flex` 取值为一个非负数字，则该数字为 `flex-grow` 值，`flex-shrink` 取 `1`，`flex-basis` 取 `0%`，如下是等同的

```css
.item {flex: 1;}

.item {
  flex-grow: 1;
  flex-shrink: 1;
  flex-basis: 0%;
}
```

当 `flex` 取值为一个长度或百分比，则视为 `flex-basis` 值，`flex-grow` 取 `1`，`flex-shrink` 取 `1`，有如下等同情况

注意 `0%` 是一个百分比而不是一个非负数字

```css
.item-1 {flex: 0%;}

.item-1 {
  flex-grow: 1;
  flex-shrink: 1;
  flex-basis: 0%;
}


.item-2 {flex: 24px;}

.item-1 {
  flex-grow: 1;
  flex-shrink: 1;
  flex-basis: 24px;
}
```

当 `flex` 取值为两个非负数字，则分别视为 `flex-grow` 和 `flex-shrink` 的值，`flex-basis` 取 `0%`，如下是等同的  

```css
.item {flex: 2 3;}

.item {
  flex-grow: 2;
  flex-shrink: 3;
  flex-basis: 0%;
}
```

当 `flex` 取值为一个非负数字和一个长度或百分比，则分别视为 `flex-grow` 和 `flex-basis` 的值，`flex-shrink` 取 `1`，如下是等同的  

```css
.item {flex: 2333 3222px;}

.item {
  flex-grow: 2333;
  flex-shrink: 1;
  flex-basis: 3222px;
}
```

`flex-basis` 规定的是子元素的基准值，所以是否溢出的计算与此属性息息相关，`flex-basis` 规定的范围取决于 `box-sizing`

这里主要讨论以下 `flex-basis` 的取值情况  

* `auto`  首先检索该子元素的主尺寸，如果主尺寸不为 `auto`，则使用值采取主尺寸之值；如果也是 `auto`，则使用值为 `content`

* `content`  指根据该子元素的内容自动布局，有的用户代理没有实现取 `content` 值，等效的替代方案是 `flex-basis` 和主尺寸都取 `auto`

* 百分比  根据其包含块（即伸缩父容器）的主尺寸计算，如果包含块的主尺寸未定义（即父容器的主尺寸取决于子元素），则计算结果和设为 `auto` 一样



## 实例

```html
<div class="parent">
  <div class="item-1"></div>
  <div class="item-2"></div>
  <div class="item-3"></div>
</div>

<style type="text/css">
.parent {
  display: flex;
  width: 600px;
}
.parent > div {
  height: 100px;
}
.item-1 {
  width: 140px;
  flex: 2 1 0%;
  background: blue;
}
.item-2 {
  width: 100px;
  flex: 2 1 auto;
  background: darkblue;
}
.item-3 {
  flex: 1 1 200px;
  background: lightblue;
}
</style>
```

主轴上父容器总尺寸为 `600px`，那么子元素的总基准值是  `0% + auto + 200px = 300px`，其中

* `0%` 即 `0` 宽度

* `auto` 对应取主尺寸即 `100px`

所以剩余空间为 `600px - 300px = 300px`，伸缩放大系数之和为 `2 + 2 + 1 = 5`，那么剩余空间分配如下

* `item-1` 和 `item-2` 各分配 `2/5`，各得 `120px`

* `item-3` 分配 `1/5`，得 `60px`

所以各项目最终宽度为

* `item-1 = 0% + 120px = 120px`

* `item-2 = auto + 120px = 220px`

* `item-3 = 200px + 60px = 260px`

当 `item-1` 基准值取 `0%` 的时候，是把该项目视为零尺寸的，故即便声明其尺寸为 `140px`，也并没有什么用，形同虚设

而 `item-2` 基准值取 `auto` 的时候，根据规则基准值使用值是主尺寸值即 `100px`，故这 `100px` 不会纳入剩余空间


