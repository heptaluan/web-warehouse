这是一篇系列文章，记录着学习 `redux`、`flux` 和 `react-redux` 各个部分的知识点，以及相关的汇总整理

[第一部分： Flux](https://github.com/hanekaoru/WebLearningNotes/blob/master/backups/react/05.md)

[第二部分： Redux](https://github.com/hanekaoru/WebLearningNotes/blob/master/backups/react/06.md)

[第三部分： Redux 官方示例剖析](https://github.com/hanekaoru/WebLearningNotes/blob/master/backups/react/07.md)

[第四部分： React-Redux](https://github.com/hanekaoru/WebLearningNotes/blob/master/backups/react/08.md)

[第五部分： Redux、Flux 和 React-Redux 三者之间的区别](https://github.com/hanekaoru/WebLearningNotes/blob/master/backups/react/09.md)

[第六部分（扩展）：纯函数（reducer）和函数式编程，以及数组中的 reduce() 方法](https://github.com/hanekaoru/WebLearningNotes/blob/master/backups/react/10.md)

----



## 第一部分：Flux

简单来说，`flux` 就是一个单向数据流

```js
View  ==>  Action  ==>  Dispatcher   ==> Store  ==>  最后再次回到 View
```

比如用户点击了一个按钮，即发送了一个 `action`，然后 `action` 发送到 `Dispatcher` 中（调度器）

`Dispatcher` 来分配这个 `action`（比如要指派给谁去做任务）给 `Store`（在一个 `flux` 结构中，`store` 可以有多个，注意和 `react-redux` 区分）

在 `Store` 中的作用就是存储并修改数据，然后传递给 `View` 进行渲染（渲染到虚拟 `DOM` 当中）



## 为什么要使用 Flux

当使用的是 `MVC` 或者 `MVVM` 架构设计模式的时候，有一个缺点，就是当项目越来越大，逻辑越来越复杂的时候，数据间的流动就会显得十分混乱

`flux` 就是致力于解决数据有序传输问题的架构设计模式（`flux` 中最大的哲学就是**数据是单向流动的**）




## Flux 的四个组成部分

主要分为四个部分 `Dispatcher`，`Action`，`Store` 和 `Views`

#### Dispatcher

* `Dispatcher` 接收 `Action`，并且要把这些 `Action` 分派给已经注册到 `Dispatcher` 的 `Store` 上

* 所有的 `Store` 都将接收所有的 `Action`

* 在每个 `App` 中，应该确保只有一个 `Dispatcher` 的实例



#### Store

* `Store` 是在 `App` 中持有数据的东西，`Stores` 将要在 `App` 的 `Dispatcher` 身上注册，以确保它们可以接收 `Actions`

* 存在 `Store` 中的数据只能够因为响应 `Action` 才能有所改变

* 在 `Store` 中不能够有公共的 `setter` 函数，仅能够有 `getter` 函数

* `Stores` 决定了它们愿意响应哪些 `Actions`

* 无论什么时候，`Store` 中的数据改变了，就会触发一个 `change` 事件

* 在一个 `App` 中可能有很多 `Store`



#### Action

* `Action` 定义了我们 `App` 中内部的 `API`

* 它们捕获所有可能改变 `App` 的任何途径、方法

* 它们是简单的 `JSON` 对象，并且要有 `'type'` 属性，和其他一些数据属性


```js
{
  type: 'delete-todo',
  todoId: '123'
}
```

* `Action` 应该具有一个语义化的命名

* 所有的 `Store` 都将接收同一个 `Action`，并且通过这同一个 `Action`，`Store` 会知道它们要清除和更新哪些数据 




#### Views

* 从 `Store` 中来的数据将被展示在 `View` 上

* `View` 层可以使用任何框架

* 当一个视图想要使用从某一个 `Store` 中来的数据，它必须订阅 subscribe（订阅）一下该 `Store` 的 change 事件

* 当 `Store` 发射（`emit`）了 `change` 事件，此时 `View` 就能够得到新的数据并且重新渲染

* 如果一个组件要使用 `Store`，但是没有订阅这个 `Store`，就会出现问题（`BUG`）

* `Action` 最常见的产生原因实在 App 的某一个部分因用户的交互行为，而被此 `View` `dispatch`（派发） 出来了


