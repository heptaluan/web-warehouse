## 实例化和原型

所有 `functions` 都拥有一个属性 `prototype`，初始化中的 `prototype` 都指向一个空的 `object`，这个属性只是在这个函数被当作构造器来调用的时候，才会有作用（其他情况下没啥用），当使用关键字 `new` 来调用一个函数，这个函数就成为了构造器，它会产生一个新的对象实例作为他的函数上下文（`function context`）

#### 对象实例化

先来看看使用和不使用 `new` 关键字分别会造成什么结果

```js
function Ninja() { }

Ninja.prototype.swingSord = function () {
  return true
}

// 不使用 new
var ninja1 = Ninja()

console.log(ninja1 === undefined)  // true

// 使用 new 关键字
var ninja2 = new Ninja()

console.log(ninja2)  // Ninja { }

console.log(ninja2.swingSord())  // true
```

从上面的例子可以看出，函数的 `prototype` 作为 `new` 出来的对象的蓝图，但是前题是这个函数是被当作构造函数来调用才行，当使用构造函数通过 `new` 关键字来构建一个对象实例的时候，这就意味着我们可以在构造函数中通过 `prototype` 来初始化一些值

```js
function Ninja() {
  this.wung = false
  this.swingSword = function () {
    return !this.wung
  }
}

Ninja.prototype.swingSword = function () {
  return this.wung
}

var ninja = new Ninja()

ninja.swingSword()  // true
```

`prototype` 不是简单的拷贝，简单的时序如下

1. 当你查看一个对象的属性，首先，这个对象检查真身的属性中是否存在，如果存在则使用这个值，如果不存在
2. 他会检查与他有关的那个 `prototype`，如果 `prototype` 存在这个属性，则使用此值，如果不存在
3. 这个值就是 `undefined`


#### 通过构造器归类对象

```js
function Ninja() { }
var ninja = new Ninja()

console.log(typeof ninja == 'object')     // true
console.log(ninja instanceof Ninja)       // true
console.log(ninja.constructor == Ninja)   // true
```

我们知道对象都有一个 `constructor` 属性，这个属性关联的就是当初创建这个对象实例的构造函数（`constructor` 属性除了可以查询到原始的构造函数），我们还可以利用这个属性来创建一个新的对象实例

```js
function Ninja() { }
var ninja = new Ninja()
var ninja2 = new ninja.constructor()

console.log(ninja2 instanceof Ninja)  // true
```

需要注意的是，一个对象实例的 `constructor` 属性是恶意被修改的


#### 继承和原型链

```js
function Person() { }
Person.prototype.dance = function () { }

function Ninja() { }

Ninja.prototype = { dance: Person.prototype.dance }

var ninja = new Ninja()

ninja instanceof Ninja    // true
ninja instanceof Person   // false
ninja instanceof Object   // true
```

运行后可以发现，`ninja` 并不是 `Person` 的实例

```js
function Person() { }
Person.prototype.dance = function () { }

function Ninja() { }

Ninja.prototype = new Person()

var ninja = new Ninja()


ninja instanceof Person           // true
ninja instanceof Object           // true
typeof ninja.dance == 'function'  // true
```

需要注意的是 不要使用 `Ninja.prototype = Person.prototype`，如果这样做，那么更改 `Ninja.prototype` 的时候同样会更改 `Person.prototype`（因为它们是同一个对象）

对象的所有属性都是继承自 `Object` 的 `prototype`，所有自然对象（`native objects`）的 `constructoe` 属性（例如 `Object`，`Array`，`String`，`Number`，`RegExp`，`Function`）都拥有 `prototype` 属性，并且它们都是可以被更改和继承的

```js
// forEach() 的实现（利用 prototypes 来增强 native JavaScript objects）
if (!Array.prototype.forEach) {
  Array.prototype.forEach = function (fn, callback) {
    for (var i = 0; i < this.length; i++) {
      fn.call(callback || null, this[i], i, this)
    }
  }
}

['a', 'b', 'c'].forEach(function (value, index, array) {
  console.log(value + ' ' + index + ' ' + (array.length - 1))
})
```


