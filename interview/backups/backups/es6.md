记录一些 `ES6` 的知识点

## let 命令

* 只要块级作用域内存在 `let` 命令，它所声明的变量就 '绑定'（`binding`）这个区域，不再受外部的影响
* `typeof` 不再是一个百分比安全的操作（如果一个变量根本没有被声明，使用 `typeof` 反而不会报错）
* `function bar(x = y, y = 2) {}` （`y` 没有声明，所以会报错）
* 不允许重复声明
* 块级作用域的出现，使得立即执行函数表达式（`IIFE`）不再必要了
* 建议避免在块级作用域内声明函数，如果确实需要，也应该写成函数表达式，而不是函数声明语句
* 允许声明函数的规则，只在使用大括号的情况下成立，如果没有使用大括号，就会报错
* 在 `ES6` 浏览器中（只对 `ES6` 的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域的函数声明当作 `let` 处理）
  * 允许在块级作用域内声明函数
  * 函数声明类似于 `var`，即会提升到全局作用域或函数作用域的头部
  * 同时，函数声明还会提升到所在的块级作用域的头部


```js
// 不报错
'use strict'
if (true) {
  function f() { }
}

// 报错
'use strict'
if (true)
  function f() { }
```




## const 命令

* 声明一个只读常量，一旦声明，常量的值就不能改变，而且必须立即初始化，不能留到以后在赋值
* `const foo = {}`
  * 常量 `foo` 储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把 `foo` 指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性
* 与 `let` 命令相似之处
  * 只能在声明所在的块级作用域内有效
  * 声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用
  * 不可重复声明








## 字符串的扩展

* 添加了遍历器接口，使得字符串可以被 `for-of` 循环遍历
* 添加了三个用于查询字符串位置的函数
  * `includes()`，返回布尔值，表示是否找到了参数字符串
  * `startsWith()`，返回布尔值，表示参数字符串是否在源字符串的头部
  * `endsWith()`，返回布尔值，表示参数字符串是否在源字符串的尾部

以上三个方法都支持第二个参数，表示开始搜索的位置，不同之处在于 `endsWith` 针对前 `n` 个字符，而其他两个方法针对从第 `n` 个位置直到字符串结束

* `repeat()` 方法返回一个新字符串，表示将原字符串重复 `n` 次
  * 如果是小数，则会被取整（`2.2 => 2, 2.9 => 2`）
  * 如果是负数（小于 `-1`）或者 `Infinity`，则会报错
  * 如果是 `0` 到 `-1` 之间的小数，则等同于 `0`，因为会先进行取整运算（`NaN` 也等同于 `0`）
  * 如果参数是字符串，则会先转换为数字（`'3' => 3, 'na' => ''`）
* 新增了模版字符串
  * 如果在模板字符串中需要使用反引号，则前面要用反斜杠转义（`\Hello World!`）
  * 如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。
  * 如果想去掉模版字符串开头和结尾处的换行，可以使用 `trim` 方法消除它。
  * 如果大括号内部是一个字符串，将会原样输出（`Hello ${'World}` => `'Hello World'`）
  * 模板字符串中也可以嵌入变量以及调用函数，比如 `${user.name}，${fn()}`

```js
$('#result').append(`
  There are <b> ${basket.count} </b> items
  in your basket, <em> ${basket.onSale} </em>
  are on sale!
`)
```




## 对象的扩展

* 允许直接写入变量和函数，作为对象的属性和方法，这时，属性名为变量名，属性值为变量的值

```js
var foo = 'bar'
var baz = { foo }
baz  // {foo: 'bar'}
```

* 方法也可以简写 `method () {return 'hello'}`
* 可以用于函数的返回值：

```js
function getPoint() {
  var x = 1
  var y = 2
  return { x, y }
}

getPoint()  // { x: 1, y: 2 }
```

* 新增属性名表达式 `obj['a' + 'bc'] = 123`
* 表达式也可以用于定义方法名
* 属性名表达式与简洁表示法，不能同时使用，否则会报错
* 特别注意，属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串 `[object, Object]`

```js
const myObject = {
  [keyA]: 'valueA',
  [keyB]: 'valueB'
}

// [keyB] 会把 [keyA] 覆盖掉，而 myObject 最后只有一个 [object Object] 属性
```




## 数值的扩展

* `parseInt()` 和 `parseFloat()` 移植到了 `Number` 对象上面 

```js
Number.parseInt('12.34') // 12
```

* `Number.isInteger()` 用来判断一个值是否为整数（在 `JavaScript` 内部，整数和浮点数是同样的储存方法，所以 `3` 和 `3.0` 被视为同一个值）
* `Math` 对象扩展
  * `Math.trunc()` 方法用于去除一个数的小数部分，返回整数部分
  * 对于非数值，内部会先使用 `Number` 方法将其先转为数值
  * 对于空值和无法截取整数的值，返回 `NaN`
* `Math.sign()` 方法用来判断一个数到底是正数，负数，还是零，会返回五种值
  * 参数为正数，返回 `+1`
  * 参数为负数，返回 `-1`
  * 参数为 `0`，返回 `0`
  * 参数为 `-0`，返回 `-0`
  * 其他值，返回 `NaN`
* `Math.cbrt()` 方法用于计算一个数的立方根
* `Math.hypot()` 返回所有参数的 平方和 的 平方根

```js
Math.hypot(3, 4)  // 5（3 的平方 + 4 的平方 等于 5 的平方）
```



## 数组的扩展

* `Array.from()` 将 类似数组的对象（`array-like-object`） 和 可遍历（`iterable`）的对象（包括 `ES6` 新增的数据结构 `Set` 和 `Map`）转为 真正的数组
  * 接受的第二个参数，作用类似于数组的 `map` 方法，用来对每个元素进行处理，将处理后的结果放入返回的数组
  * 如果 `Array.from()` 没有参数，就返回一个空数组
* `Array.of()` 用于将一组值，转换为数组（因为在 `ES5` 中，参数个数的不同，会导致 `Array()` 的行为有差异）
* `find()` 方法，用于找出第一个符合条件的数组成员，参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为 `true` 的成员，并返回，如果没有找到符合条件的成员，则返回 `undefined`
  * 回调函数可以接受三个参数，依次为 当前的值、当前的位置 和 原数组
* `findIndex()` 方法的用法与 `find()` 方法非常相似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回 `-1`
  * `find()` 方法和 `findIndex()` 方法都可以发现 `NaN`，弥补了数组的 `indexOf` 方法的不足
* `fill()` 方法使用给定值，填充一个数组
  * 需要注意的是，数组中已有的元素，会被全部抹去
  * 可以指定第二个和第三个参数，用于指定填充的起始位置和结束位置
* 提供了三个新的方法来用于遍历数组，它们都返回一个遍历器对象，可以用 `for-of` 循环进行遍历（如果不使用 `for-of` 循环，可以手动调用遍历器对象的 `next()` 方法，进行遍历）
  * `keys()` 是对键名的遍历
  * `values()` 是对键值的遍历
  * `entries()` 是对键值对的遍历
* `Array.prototype.includes` 方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的 `includes` 方法类似
  * 第二个参数表示搜索的起始位置，默认为 `0`，如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为 `-4`，但数组长度为 `3`），则会重置为从 `0` 开始
* `Map` 和 `Set` 数据结构有一个 `has` 方法，需要注意与 `includes` 区分
  * `Map` 结构的 `has` 方法，是用来查找键名的，比如 `Map.prototype.has(key)`、`WeakMap.prototype.has(key)`、`Reflect.has(target, propertyKey)`
  * `Set` 结构的 `has` 方法，是用来查找值的，比如 `Set.prototype.has(value)`、`WeakSet.prototype.has(value)`



## 解构

```js
// 属于'模式匹配'，只要等号两边的模式相同，左边的变量就会被赋予对应的值
var [a, b, c] = [1, 2, 3]
```

* 如果解构不成功，变量的值就等于 `undefined`
* 如果等号右边不是数组（不是可遍历的解构，不具有 `Iterator` 接口），那么将会报错（`number`，`string`，`false`，`NaN`，`undefined`，`null`，`{}` 等）
* 只要某种数据具有 `Iterator` 接口，都可以采用数组形式的解构赋值
* 解构赋值允许指定默认值（内部使用的是严格相等运算符 `===`）
* 默认值可以引用解构赋值的其他变量，但该变量必须已经声明
* 对象的解构

```js
var { foo, bar } = { foo: 'aaa', bar: 'bbb' }
```

* 对象的属性没有次序，变量必须与属性同名，才能取到正确的值

```js
let foo
({ foo } = { foo: 1 }) // success

let baz
({ bar: baz } = { bar: 1 }) // success
```

上例中的圆括号是必须的，否则会报错，因为解析器会将起首的大括号，理解成一个代码块，而不是赋值语句



## 字符串的解构

* 字符串也可以解构赋值，这是因为此时，字符串被转换成了一个类似数组的对象



## 数值和布尔值的解构

* 解构赋值的时候，如果等号右边是数值和布尔值，则会先转为对象
* 规则是，只要等号右边的值不是对象，就先将其转为对象，由于 `undefined` 和 `null` 无法转为对象，所以对它们进行解构赋值，都会报错



## 函数相关

* 在 `ES6` 中，允许函数的参数设置默认值，即直接写在参数定义的后面（函数参数的默认值）
  * 参数变量是默认声明的，所以不能使用 `let` 或者 `const` 再次声明
  * 指定了默认值以后，函数的 `length` 属性，将返回没有指定默认值的参数个数，也就是说，指定了默认值以后，`length` 属性将失效（`length` 属性的含义是，该函数预期传入的参数个数，某个参数指定默认值以后，预期传入的参数个数就不包括这个参数了）
* 如果设置了默认值的参数不是尾参数（即设置默认值的不是最后一个参数），那么 `length` 属性也不再计入后面的参数了
* 如果参数默认值是一个变量，则该变量所处的作用域，与其他变量的作用域规则是一样的，即先是当前函数的作用域，然后才是全局作用域
* 用于将一个数组转为用都好分隔的参数序列（`console.log(...[1, 2, 3])`）
* 在 `ES5` 中，如果将一个匿名函数赋值给一个变量，其 `name` 属性，会返回空字符串，而 `ES6` 中修正了这个问题，会返回实际的函数名
  * `Function` 构造函数返回的函数实例，`name` 属性的值为 `anonymous`
  * `bind` 返回的函数，`name` 属性会加上 `bound` 前缀
* 如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用 `return` 语句返回

```js
var sum = (num1, num2) => { return num1 + num2 }
```

* 由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号

```js
var getTempItem = id => ({ id: id, name: 'Temp' })
```

* 箭头函数的使用注意点
  * 函数体内的 `this` 对象，就是定义时所在的对象，而不是使用时所在的对象（例如在 `Vue` 的实例属性或回调函数中就不建议使用箭头函数，因为箭头函数绑定父上下文，所以 `this` 不会像预想的一样是 `Vue` 实例，而是对应方法未被定义）
  * 不可以当作构造函数，也就是说，不可以使用 `new` 命令，否则会抛出一个错误
  * 不可以使用 `arguments` 对象，该对象在函数体内不存在。如果要用，可以用 `Rest` 参数代替
  * 不可以使用 `yield` 命令，因此箭头函数不能用作 `Generator` 函数
  * 需要特别注意的是：`this` 对象的指向是可变的，但是在箭头函数中，它是固定的
  * 箭头函数中的 `this` 指向的固定化，并不是因为箭头函数内部有绑定 `this` 的机制，实际原因是箭头函数根本没有自己的 `this`，导致内部的 `this` 就是外层代码块的 `this`（正式因为它没有 `this`，所以也就不能用作构造函数）




## Symbol

* `ES6` 引入了一种新的原始数据类型 `Symbol`，表示独一无二的值，它是 `JavaScript` 第七种数据类型

```js
// 变量 s 就是一个独一无二的值
let s = Symbol()

// typeof 运算符的结果，表明变量 s 是 Symbol 数据类型，而不是字符串之类的其他类型
typeof s
// 'symbol'
```


待续...




