## 代理模式

在代理模式中，一个对象充当另一个对象的接口，它与外观模式的区别之处在于，在外观模式中您所拥有的是合并了多个方法调用的便利之法，代理则介于对象的客户端和对象本身之间，并且对该对象的访问进行保护，比如一个展开多个视频的列表，通过引入代理模式，即可将多个 `Web` 服务请求合并成单个请求的能力，下面这个 `proxy` 简易了一个队列以收集过去 `50ms` 接收到的视频 `ID`，然后排空队列，同时还调用 `http` 并向它提供自己的回调函数

```js
var proxy = {
  ids: [],
  delay: 50,
  timeout: null,
  callback: null,
  context: null,
  makeRequest: function (id, callback, context) {
    // 加入到队列中
    this.ids.push(id)
    this.callback = callback
    this.context = context
    // 设置超时事件
    if (!this.timeout) {
      this.timeout = setTimeout(function () {
        proxy.flush()
      }, this.delay)
    }
  },
  flush: function () {
    http.makeRequest(this.id, 'proxy.handler')
    // 清除超时设置和队列
    this.timeout = null
    this.ids = []
  },
  handler: function (data) {
    var i, max
    // 单个视频
    if (parseInt(data.query.count, 10) === 1) {
      proxy.callback.call(proxy.context, data.query.results.videos)
      return
    }
    // 多个视频
    for (i = 0; max = data.query.results.Video.length, i < max; i += 1) {
      proxy.callback.call(proxy.context, data.query.results.videos[i])
    }
  }
}
```


#### 缓存代理

代理可以通过将以前的请求结果缓存到新的 `cache` 属性中，从而进一步保护对本地对象的 `http` 的访问，如果 `videos` 对象恰好再一次请求有关同一个视频 `ID` 的信息，`proxy` 可以从缓存中取出该信息，从而节省了该网络往返消息
